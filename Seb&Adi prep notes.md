
## Separation of Concerns:

### FrontEnd (primarily typescript):
- Visuals (locofy generated)
- Typescript logic for signing-in/creating accounts and any other management of user sessions through firebase auth
- Typescript logic for integrating plaid sdk and sending public token to backend (very simple)
- Typescript logic for routing to backend (for sending data to be stored(https), and getting gpt prompts(websocket))
- Typescript for directly modifying firestore from frontend; strictly for non-sensitive data e.g. user prefs

### Backend (all in python):
- Bit of flask routing to handle front-to-backend communication
- Logic for receiving data from frontend to be stored in firestore (sensitive data like DOB, Income, Debts, SSN should be encrypted before being put in firestore, even though firestore offers a layer of encryption)
- Logic for receiving firebase idToken (verifying it, if we decide to do that) and extracting uid to be used as key in firestore (or added as key if creating account)
- Logic for deleting accounts and their data on firebase auth and firestore (if we decide to implement that)
- Logic for receiving plaid public token and using plaid api to get access token, then encrypt and store it in firestore
- Offering logic/method(strictly for backend use) for easy querying of secure financial info from plaid (so that liam&max can easily integrate that data into there backend prompt engineering logic)
- Logic for maintaining Google Cloud Secret Manager and adding/getting secrets


## What we need to know / Importance
- **Figma+Locofy** (used for all of our visuals, saving us enough time to make it all possible)
- **Typescript** (used for pretty much everything in our controller/middle layer. E.g. routing to backend, chatgpt api integration/logic, non-sensitive firebase logic, any patches/logic needed for the locofy generated code) *This will probably end up being what we actually writing the most in
- **Firebase products** (Cloud Firestore used for databases, Firebase also used for authentication)
  * Firestore needs to be set up carefully. We can specify varying security rules for the database so that sensitive data can only be accessed by server-side/backend and non-sensitive data   can be easily accessed by frontend (if we really want; Might be more simple to just ask backend everytime we want data idk)
  * Firebase auth is simple to integrate as it comes with customizable ui components ready for use. We can use their functions for creating accounts / signing into accounts
  * On sign in they handle verifying if that account exists and then give us an idToken (expires after an hour of user inactivity) which just contains a uid they generate for us and a their email and password.
  * On creation we also get that idToken (which contains the new uid) and we can send the uid (wrapped in the idToken) to the backend where it will be used as a key in firestore to the document(s) containing that users data
  * Whenever an account is created or signed into firebase sets that account as the currentUser. We can easily access currentUser to check if it is null (no one signed in) or to get the idToken(contains uid) for that currentUser which can be used to get the data for the currentUser by uid
  * By default Firebase remembers the currentUser (within the browser) for up to an hour of inactivity. So in that hour they can close our tab and search our site again and still be considered the currentUser
  * That means we can check if the currentUser is null when they click “Try now” on the landing page and if the currentUser is not null we can send them straight to their main chat page, skipping sign in
  * NOTE: When an idToken is sent to the backend its a good idea to run it through a verification function(which calls some simple firebase methods to verify the token)  before using it for anything. This ensures it’s a valid untampered token generated by fireBase on the frontend and not some hacker who is trying to sent bad tokens to our backend. **This might be a time allowing thing depending on if we decide it’s important or not for hackathon purpouses 
- **Plaid** (used for securely pulling user bank info and credit score)
  * On the frontend we can easily integrate the plaid sdk which will take the user through there secure form and once they’re done it gives the frontend a public token. 
  * We then send that public token to the backend via http where it can securely be exchanged via the plaid api for an access token which can actually be used to pull user financial info via plaid api. 
  * The access token should be encrypted (gpt recommended “AES-256” algo. for encrypting), we’ll also have to figure out holding on to the keys for encrypting/decrypting.
  * Once encrypted it can be stored in Firestore 
  * Important disclaimer; we need to present a consent form when pulling credit score: By connecting your credit profile, you consent to our performing a soft credit check to retrieve your credit score. This will not affect your credit score.
  * Getting credit score works the same way as banking info (public token -> access token -> encrypt -> store)
  * NOTE: We will have to use Plaid sandbox for the hackathon which essentially simulates a real user and populates the form automatically with simulated data. For testing and demo purposes this is perfect, we’ll just have to mention when presenting that we’d simply need to upgrade our plaid api for production, but it would work exactly the same other than that.
- Chatgpt api
- **Google Cloud Secret Manager**
  * Used to hold onto all our "secrets" e.g. API keys&Database Credentials(although these can be stored as backend environment variables on deployment), and most importantly the keys to our encrypted data (plaid uid's and anything else that we encrypt)
  * Pretty easy to set up, doesn't require setup files
  * We'll make getSecret and setSecret functions for easy use across the backend
- Live News API

## Deployment
- **Render**:
  * Allows us to link a repo and set up the backend as web service, and the frontend as a static site (2 separate components)
  * It generates a url for the backend so we can update the urls in our frontend to point to the actual backend
  * Interesting note, http is not encrypted it needs TLS for that (which makes it https) but luckily render handles that for us, so the url they’ll give us to the backend will be https and therefore automatically encrypted. The url they give us for the frontend will also be https
  * We’ll have to install the requirements for the backend on the web service, and we can add any API keys or Database credentials as Environment variables
  * We’ll have to build our frontend and then set it up on render. Again, we can put any handy credentials as Environment variables
  * We can set our custom url for the frontend on render (and we’ll add a few things with our domain registrar so that it communicates to render)
  * Then it should be all good. Free tier should be enough for render
